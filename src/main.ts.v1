import Phaser from "phaser";

type MsgType =
    | "WELCOME"
    | "STATE_DELTA"
    | "COMBAT"
    | "MOVE_REQ"
    | "TARGET_REQ"
    | "PICKUP_REQ";

type WsMessage<T> = { type: MsgType; payload: T };

type WelcomePayload = { playerId: number; mapId: string; tickRate: number };
type EntityView = { id: number; kind: string; x: number; y: number; hp: number; maxHp: number; targetId: number };
type StateDeltaPayload = { tick: number; updates: EntityView[]; removes: number[] };
type CombatPayload = { tick: number; attackerId: number; targetId: number; dmg: number; crit: boolean; miss: boolean; targetHp: number };

const TILE_W = 64;
const TILE_H = 32;

function worldToScreen(x: number, y: number) {
    const sx = (x - y) * (TILE_W / 2);
    const sy = (x + y) * (TILE_H / 2);
    return { sx, sy };
}

function screenToWorld(sx: number, sy: number) {
    const tx = (sy / (TILE_H / 2) + sx / (TILE_W / 2)) / 2;
    const ty = (sy / (TILE_H / 2) - sx / (TILE_W / 2)) / 2;
    return { x: tx, y: ty };
}

class MainScene extends Phaser.Scene {
    ws!: WebSocket;
    myId = 0;
    myTargetId = 0;

    entities = new Map<number, Phaser.GameObjects.Container>();
    hpTexts = new Map<number, Phaser.GameObjects.Text>();
    lastEntityView = new Map<number, EntityView>();

    seq = 0;

    // 타겟 링
    targetRing?: Phaser.GameObjects.Ellipse;

    // HUD
    uiLayer!: Phaser.GameObjects.Container;
    hpBarBg!: Phaser.GameObjects.Rectangle;
    hpBarFg!: Phaser.GameObjects.Rectangle;
    hpText!: Phaser.GameObjects.Text;

    targetName!: Phaser.GameObjects.Text;
    targetHpBg!: Phaser.GameObjects.Rectangle;
    targetHpFg!: Phaser.GameObjects.Rectangle;

    toastText!: Phaser.GameObjects.Text;
    toastTimer?: Phaser.Time.TimerEvent;

    create() {
        const cam = this.cameras.main;
        cam.setBackgroundColor("#161616");

        // 월드 원점(0,0) 기준으로 그리드 생성
        this.drawIsoGrid(120, 120);

        // 카메라 초기 위치(대충 중앙)
        const start = worldToScreen(18, 18);
        cam.centerOn(start.sx, start.sy);

        // 타겟 링(발밑)
        this.targetRing = this.add.ellipse(0, 0, 36, 18);
        this.targetRing.setStrokeStyle(2, 0xff3333, 1);
        this.targetRing.setVisible(false);
        this.targetRing.setDepth(3000);

        this.createHud();

        this.ws = new WebSocket(`ws://${location.hostname}:8080/ws`);
        this.ws.onmessage = (ev) => this.onWs(ev.data);

        // 클릭: (1) 드랍 -> 줍기 (2) 몹 -> 타겟 (3) 이동
        this.input.on("pointerdown", (p: Phaser.Input.Pointer) => {
            const sx = p.worldX; // cam 이동 반영된 "월드 좌표"
            const sy = p.worldY;

            const dropHit = this.pickEntityAtScreen(sx, sy, "D");
            if (dropHit) {
                this.send("PICKUP_REQ", { dropId: dropHit });
                return;
            }

            const mobHit = this.pickEntityAtScreen(sx, sy, "M");
            if (mobHit) {
                this.send("TARGET_REQ", { targetId: mobHit });
                return;
            }

            const w = screenToWorld(sx, sy);
            this.send("MOVE_REQ", { seq: ++this.seq, x: w.x, y: w.y });
        });
    }

    drawIsoGrid(w: number, h: number) {
        const g = this.add.graphics();
        g.lineStyle(1, 0x2c2c2c, 1);

        // 서버 맵은 200x200인데, 일단 보기 좋게 120x120 그립니다(너무 크면 무거움)
        for (let x = 0; x < w; x++) {
            for (let y = 0; y < h; y++) {
                const { sx, sy } = worldToScreen(x, y);
                g.strokePoints(
                    [
                        new Phaser.Math.Vector2(sx, sy - TILE_H / 2),
                        new Phaser.Math.Vector2(sx + TILE_W / 2, sy),
                        new Phaser.Math.Vector2(sx, sy + TILE_H / 2),
                        new Phaser.Math.Vector2(sx - TILE_W / 2, sy),
                        new Phaser.Math.Vector2(sx, sy - TILE_H / 2)
                    ],
                    false
                );
            }
        }
        // ✅ 절대 midPoint로 옮기지 않습니다.
        g.setPosition(0, 0);
    }

    pickEntityAtScreen(sx: number, sy: number, kind: string): number | null {
        let best: { id: number; d2: number } | null = null;

        for (const [id, c] of this.entities.entries()) {
            const k = (c.getData("kind") as string) || "";
            if (k !== kind) continue;

            const dx = c.x - sx;
            const dy = c.y - sy;
            const d2 = dx * dx + dy * dy;

            if (d2 < 900) {
                if (!best || d2 < best.d2) best = { id, d2 };
            }
        }
        return best ? best.id : null;
    }

    onWs(raw: string) {
        const msg = JSON.parse(raw) as WsMessage<any>;

        if (msg.type === "WELCOME") {
            const p = msg.payload as WelcomePayload;
            this.myId = p.playerId;
            this.toast(`접속: P${this.myId}`);
            return;
        }

        if (msg.type === "STATE_DELTA") {
            const p = msg.payload as StateDeltaPayload;

            for (const id of p.removes) {
                this.lastEntityView.delete(id);
                this.removeEntity(id);
            }

            for (const e of p.updates) {
                this.lastEntityView.set(e.id, e);
                this.upsertEntity(e);
            }

            this.sortDepth();
            this.updateTargetRingAndHud();
            return;
        }

        if (msg.type === "COMBAT") {
            const p = msg.payload as CombatPayload;
            const target = this.entities.get(p.targetId);
            if (target) {
                const t = this.add.text(target.x, target.y - 40, p.miss ? "MISS" : `-${p.dmg}`, {
                    fontSize: "14px",
                    color: p.crit ? "#ffd34d" : "#ffffff"
                });
                this.tweens.add({
                    targets: t,
                    y: t.y - 20,
                    alpha: 0,
                    duration: 500,
                    onComplete: () => t.destroy()
                });
            }
        }
    }

    upsertEntity(e: EntityView) {
        const { sx, sy } = worldToScreen(e.x, e.y);
        const px = sx;
        const py = sy;

        let c = this.entities.get(e.id);

        if (!c) {
            const body =
                e.kind === "P"
                    ? this.add.circle(0, 0, 10, 0x4da3ff)
                    : e.kind === "M"
                        ? this.add.circle(0, 0, 10, 0xff5a5a)
                        : this.add.rectangle(0, 0, 12, 12, 0xffff66);

            const label = e.kind === "D" ? `DROP` : `${e.kind}${e.id}`;
            const name = this.add.text(-16, -28, label, { fontSize: "10px", color: "#ddd" });

            let hp: Phaser.GameObjects.Text | null = null;
            const children: Phaser.GameObjects.GameObject[] = [body, name];

            if (e.kind !== "D") {
                hp = this.add.text(-18, 14, `${e.hp}/${e.maxHp}`, { fontSize: "10px", color: "#aaffaa" });
                children.push(hp);
            }

            c = this.add.container(px, py, children);
            c.setData("kind", e.kind);
            c.setData("id", e.id);

            this.entities.set(e.id, c);
            if (hp) this.hpTexts.set(e.id, hp);
        } else {
            c.x = px;
            c.y = py;
            const hp = this.hpTexts.get(e.id);
            if (hp && e.kind !== "D") hp.setText(`${e.hp}/${e.maxHp}`);
        }

        if (e.id === this.myId) {
            this.myTargetId = e.targetId || 0;
            this.setMyHp(e.hp, e.maxHp);

            // 카메라 따라가기(이제 그리드 안 사라짐)
            this.cameras.main.centerOn(px, py);
        }
    }

    removeEntity(id: number) {
        const c = this.entities.get(id);
        if (c) c.destroy();
        this.entities.delete(id);

        const hp = this.hpTexts.get(id);
        if (hp) hp.destroy();
        this.hpTexts.delete(id);
    }

    sortDepth() {
        const arr = Array.from(this.entities.values());
        arr.sort((a, b) => a.y - b.y);
        arr.forEach((c, i) => c.setDepth(i));
    }

    updateTargetRingAndHud() {
        if (!this.targetRing) return;

        if (!this.myTargetId) {
            this.targetRing.setVisible(false);
            this.setTargetFrame("대상 없음", 0, 1);
            return;
        }

        const tObj = this.entities.get(this.myTargetId);
        const tView = this.lastEntityView.get(this.myTargetId);

        if (!tObj || !tView) {
            this.targetRing.setVisible(false);
            this.setTargetFrame("대상 없음", 0, 1);
            return;
        }

        this.targetRing.setVisible(true);
        this.targetRing.x = tObj.x;
        this.targetRing.y = tObj.y + 10;
        this.targetRing.setDepth(tObj.depth - 1);

        this.setTargetFrame(`${tView.kind}${tView.id}`, tView.hp, tView.maxHp);
    }

    send(type: MsgType, payload: any) {
        if (this.ws.readyState !== WebSocket.OPEN) return;
        this.ws.send(JSON.stringify({ type, payload }));
    }

    // ---------- HUD ----------
    createHud() {
        const w = this.scale.width;
        const h = this.scale.height;

        this.uiLayer = this.add.container(0, 0).setDepth(5000);

        this.hpBarBg = this.add.rectangle(20, 20, 220, 16, 0x333333).setOrigin(0, 0);
        this.hpBarFg = this.add.rectangle(22, 22, 216, 12, 0xff3333).setOrigin(0, 0);
        this.hpText = this.add.text(20, 40, "HP 100/100", { fontSize: "12px", color: "#ffffff" });

        // UI는 카메라 영향 받지 않게 고정
        this.hpBarBg.setScrollFactor(0);
        this.hpBarFg.setScrollFactor(0);
        this.hpText.setScrollFactor(0);

        this.uiLayer.add([this.hpBarBg, this.hpBarFg, this.hpText]);

        const tfX = w / 2 - 140;
        const tfY = 10;
        const frameBg = this.add.rectangle(tfX, tfY, 280, 46, 0x000000, 0.55).setOrigin(0, 0);
        this.targetName = this.add.text(tfX + 10, tfY + 6, "대상 없음", { fontSize: "12px", color: "#ffffff" });
        this.targetHpBg = this.add.rectangle(tfX + 10, tfY + 26, 260, 10, 0x333333).setOrigin(0, 0);
        this.targetHpFg = this.add.rectangle(tfX + 10, tfY + 26, 260, 10, 0xff3333).setOrigin(0, 0);

        frameBg.setScrollFactor(0);
        this.targetName.setScrollFactor(0);
        this.targetHpBg.setScrollFactor(0);
        this.targetHpFg.setScrollFactor(0);

        this.uiLayer.add([frameBg, this.targetName, this.targetHpBg, this.targetHpFg]);

        this.toastText = this.add.text(w / 2, h - 90, "", { fontSize: "14px", color: "#ffffaa" }).setOrigin(0.5);
        this.toastText.setAlpha(0);
        this.toastText.setScrollFactor(0);
        this.uiLayer.add(this.toastText);
    }

    setMyHp(hp: number, maxHp: number) {
        const ratio = maxHp > 0 ? hp / maxHp : 0;
        this.hpBarFg.width = 216 * Phaser.Math.Clamp(ratio, 0, 1);
        this.hpText.setText(`HP ${hp}/${maxHp}`);
    }

    setTargetFrame(name: string, hp: number, maxHp: number) {
        this.targetName.setText(name);
        const ratio = maxHp > 0 ? hp / maxHp : 0;
        this.targetHpFg.width = 260 * Phaser.Math.Clamp(ratio, 0, 1);
    }

    toast(msg: string) {
        this.toastText.setText(msg);
        this.toastText.setAlpha(1);
        if (this.toastTimer) this.toastTimer.remove(false);
        this.toastTimer = this.time.addEvent({
            delay: 900,
            callback: () => this.tweens.add({ targets: this.toastText, alpha: 0, duration: 250 })
        });
    }
}

new Phaser.Game({
    type: Phaser.AUTO,
    width: window.innerWidth,
    height: window.innerHeight,
    parent: "app",
    scene: [MainScene]
});
